!(function (t, e) {
  "object" == typeof exports && "undefined" != typeof module
    ? e(exports)
    : "function" == typeof define && define.amd
    ? define(["exports"], e)
    : e(((t = t || self).window = t.window || {}));
})(this, function (t) {
  "use strict";
  function n(t) {
    return "string" == typeof t;
  }
  var w = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
    N = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
    x = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi,
    o = /(^[#\.][a-z]|[a-y][a-z])/i,
    B = Math.PI / 180,
    D = (Math.PI, Math.sin),
    E = Math.cos,
    $ = Math.abs,
    k = Math.sqrt,
    s = function _isNumber(t) {
      return "number" == typeof t;
    },
    h = function _round(t) {
      return ~~(1e5 * t + (t < 0 ? -0.5 : 0.5)) / 1e5;
    };
  function reverseSegment(t) {
    var e,
      r = 0;
    for (t.reverse(); r < t.length; r += 2) (e = t[r]), (t[r] = t[r + 1]), (t[r + 1] = e);
    t.reversed = !t.reversed;
  }
  var A = {
    rect: "rx,ry,x,y,width,height",
    circle: "r,cx,cy",
    ellipse: "rx,ry,cx,cy",
    line: "x1,x2,y1,y2",
  };
  function convertToPath(t, e) {
    var r,
      n,
      o,
      a,
      i,
      s,
      h,
      l,
      g,
      c,
      p,
      f,
      u,
      d,
      P,
      _,
      v,
      m,
      y,
      w,
      M,
      x,
      T = t.tagName.toLowerCase(),
      b = 0.552284749831;
    return "path" !== T && t.getBBox
      ? ((s = (function _createPath(t, e) {
          var r,
            n = document.createElementNS("http://www.w3.org/2000/svg", "path"),
            o = [].slice.call(t.attributes),
            a = o.length;
          for (e = "," + e + ","; -1 < --a; )
            (r = o[a].nodeName.toLowerCase()),
              e.indexOf("," + r + ",") < 0 && n.setAttributeNS(null, r, o[a].nodeValue);
          return n;
        })(t, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points")),
        (x = (function _attrToObj(t, e) {
          for (var r = e ? e.split(",") : [], n = {}, o = r.length; -1 < --o; )
            n[r[o]] = +t.getAttribute(r[o]) || 0;
          return n;
        })(t, A[T])),
        "rect" === T
          ? ((a = x.rx),
            (i = x.ry),
            (n = x.x),
            (o = x.y),
            (c = x.width - 2 * a),
            (p = x.height - 2 * i),
            (r =
              a || i
                ? "M" +
                  (_ = (d = (u = n + a) + c) + a) +
                  "," +
                  (m = o + i) +
                  " V" +
                  (y = m + p) +
                  " C" +
                  [
                    _,
                    (w = y + i * b),
                    (P = d + a * b),
                    (M = y + i),
                    d,
                    M,
                    d - (d - u) / 3,
                    M,
                    u + (d - u) / 3,
                    M,
                    u,
                    M,
                    (f = n + a * (1 - b)),
                    M,
                    n,
                    w,
                    n,
                    y,
                    n,
                    y - (y - m) / 3,
                    n,
                    m + (y - m) / 3,
                    n,
                    m,
                    n,
                    (v = o + i * (1 - b)),
                    f,
                    o,
                    u,
                    o,
                    u + (d - u) / 3,
                    o,
                    d - (d - u) / 3,
                    o,
                    d,
                    o,
                    P,
                    o,
                    _,
                    v,
                    _,
                    m,
                  ].join(",") +
                  "z"
                : "M" + (n + c) + "," + o + " v" + p + " h" + -c + " v" + -p + " h" + c + "z"))
          : "circle" === T || "ellipse" === T
          ? ((l = "circle" === T ? (a = i = x.r) * b : ((a = x.rx), (i = x.ry) * b)),
            (r =
              "M" +
              ((n = x.cx) + a) +
              "," +
              (o = x.cy) +
              " C" +
              [
                n + a,
                o + l,
                n + (h = a * b),
                o + i,
                n,
                o + i,
                n - h,
                o + i,
                n - a,
                o + l,
                n - a,
                o,
                n - a,
                o - l,
                n - h,
                o - i,
                n,
                o - i,
                n + h,
                o - i,
                n + a,
                o - l,
                n + a,
                o,
              ].join(",") +
              "z"))
          : "line" === T
          ? (r = "M" + x.x1 + "," + x.y1 + " L" + x.x2 + "," + x.y2)
          : ("polyline" !== T && "polygon" !== T) ||
            ((r =
              "M" +
              (n = (g = (t.getAttribute("points") + "").match(N) || []).shift()) +
              "," +
              (o = g.shift()) +
              " L" +
              g.join(",")),
            "polygon" === T && (r += "," + n + "," + o + "z")),
        s.setAttribute("d", rawPathToString((s._gsRawPath = stringToRawPath(r)))),
        e && t.parentNode && (t.parentNode.insertBefore(s, t), t.parentNode.removeChild(t)),
        s)
      : t;
  }
  function arcToSegment(t, e, r, n, o, a, i, s, h) {
    if (t !== s || e !== h) {
      (r = $(r)), (n = $(n));
      var l = (o % 360) * B,
        g = E(l),
        c = D(l),
        p = Math.PI,
        f = 2 * p,
        u = (t - s) / 2,
        d = (e - h) / 2,
        P = g * u + c * d,
        _ = -c * u + g * d,
        v = P * P,
        m = _ * _,
        y = v / (r * r) + m / (n * n);
      1 < y && ((r = k(y) * r), (n = k(y) * n));
      var w = r * r,
        M = n * n,
        x = (w * M - w * m - M * v) / (w * m + M * v);
      x < 0 && (x = 0);
      var T = (a === i ? -1 : 1) * k(x),
        b = ((r * _) / n) * T,
        S = ((-n * P) / r) * T,
        N = g * b - c * S + (t + s) / 2,
        z = c * b + g * S + (e + h) / 2,
        R = (P - b) / r,
        A = (_ - S) / n,
        O = (-P - b) / r,
        Y = (-_ - S) / n,
        j = R * R + A * A,
        C = (A < 0 ? -1 : 1) * Math.acos(R / k(j)),
        F = (R * Y - A * O < 0 ? -1 : 1) * Math.acos((R * O + A * Y) / k(j * (O * O + Y * Y)));
      isNaN(F) && (F = p), !i && 0 < F ? (F -= f) : i && F < 0 && (F += f), (C %= f), (F %= f);
      var I,
        V = Math.ceil($(F) / (f / 4)),
        L = [],
        X = F / V,
        U = ((4 / 3) * D(X / 2)) / (1 + E(X / 2)),
        G = g * r,
        Q = c * r,
        H = c * -n,
        q = g * n;
      for (I = 0; I < V; I++)
        (P = E((o = C + I * X))),
          (_ = D(o)),
          (R = E((o += X))),
          (A = D(o)),
          L.push(P - U * _, _ + U * P, R + U * A, A - U * R, R, A);
      for (I = 0; I < L.length; I += 2)
        (P = L[I]), (_ = L[I + 1]), (L[I] = P * G + _ * H + N), (L[I + 1] = P * Q + _ * q + z);
      return (L[I - 2] = s), (L[I - 1] = h), L;
    }
  }
  function stringToRawPath(t) {
    function sc(t, e, r, n) {
      (g = (r - t) / 3), (c = (n - e) / 3), s.push(t + g, e + c, r - g, n - c, r, n);
    }
    var e,
      r,
      n,
      o,
      a,
      i,
      s,
      h,
      l,
      g,
      c,
      p,
      f,
      u =
        (t + "")
          .replace(x, function (t) {
            var e = +t;
            return e < 1e-4 && -1e-4 < e ? 0 : e;
          })
          .match(w) || [],
      d = [],
      P = 0,
      _ = 0,
      v = u.length,
      m = 0,
      y = "ERROR: malformed path: " + t;
    if (!t || !isNaN(u[0]) || isNaN(u[1])) return console.log(y), d;
    for (e = 0; e < v; e++)
      if (
        ((f = a),
        isNaN(u[e]) ? (i = (a = u[e].toUpperCase()) !== u[e]) : e--,
        (n = +u[e + 1]),
        (o = +u[e + 2]),
        i && ((n += P), (o += _)),
        e || ((h = n), (l = o)),
        "M" === a)
      )
        s && (s.length < 8 ? (d.length -= 1) : (m += s.length)),
          (P = h = n),
          (_ = l = o),
          (s = [n, o]),
          d.push(s),
          (e += 2),
          (a = "L");
      else if ("C" === a)
        i || (P = _ = 0),
          (s = s || [0, 0]).push(
            n,
            o,
            P + 1 * u[e + 3],
            _ + 1 * u[e + 4],
            (P += 1 * u[e + 5]),
            (_ += 1 * u[e + 6])
          ),
          (e += 6);
      else if ("S" === a)
        (g = P),
          (c = _),
          ("C" !== f && "S" !== f) || ((g += P - s[s.length - 4]), (c += _ - s[s.length - 3])),
          i || (P = _ = 0),
          s.push(g, c, n, o, (P += 1 * u[e + 3]), (_ += 1 * u[e + 4])),
          (e += 4);
      else if ("Q" === a)
        (g = P + (2 / 3) * (n - P)),
          (c = _ + (2 / 3) * (o - _)),
          i || (P = _ = 0),
          (P += 1 * u[e + 3]),
          (_ += 1 * u[e + 4]),
          s.push(g, c, P + (2 / 3) * (n - P), _ + (2 / 3) * (o - _), P, _),
          (e += 4);
      else if ("T" === a)
        (g = P - s[s.length - 4]),
          (c = _ - s[s.length - 3]),
          s.push(
            P + g,
            _ + c,
            n + (2 / 3) * (P + 1.5 * g - n),
            o + (2 / 3) * (_ + 1.5 * c - o),
            (P = n),
            (_ = o)
          ),
          (e += 2);
      else if ("H" === a) sc(P, _, (P = n), _), (e += 1);
      else if ("V" === a) sc(P, _, P, (_ = n + (i ? _ - P : 0))), (e += 1);
      else if ("L" === a || "Z" === a)
        "Z" === a && ((n = h), (o = l), (s.closed = !0)),
          ("L" === a || 0.5 < $(P - n) || 0.5 < $(_ - o)) &&
            (sc(P, _, n, o), "L" === a && (e += 2)),
          (P = n),
          (_ = o);
      else if ("A" === a) {
        if (
          (p = arcToSegment(
            P,
            _,
            +u[e + 1],
            +u[e + 2],
            +u[e + 3],
            +u[e + 4],
            +u[e + 5],
            (i ? P : 0) + 1 * u[e + 6],
            (i ? _ : 0) + 1 * u[e + 7]
          ))
        )
          for (r = 0; r < p.length; r++) s.push(p[r]);
        (P = s[s.length - 2]), (_ = s[s.length - 1]), (e += 7);
      } else console.log(y);
    return (
      (e = s.length) < 6
        ? (d.pop(), (e = 0))
        : s[0] === s[e - 2] && s[1] === s[e - 1] && (s.closed = !0),
      (d.totalPoints = m + e),
      d
    );
  }
  function rawPathToString(t) {
    s(t[0]) && (t = [t]);
    var e,
      r,
      n,
      o,
      a = "",
      i = t.length;
    for (r = 0; r < i; r++) {
      for (o = t[r], a += "M" + h(o[0]) + "," + h(o[1]) + " C", e = o.length, n = 2; n < e; n++)
        a +=
          h(o[n++]) +
          "," +
          h(o[n++]) +
          " " +
          h(o[n++]) +
          "," +
          h(o[n++]) +
          " " +
          h(o[n++]) +
          "," +
          h(o[n]) +
          " ";
      o.closed && (a += "z");
    }
    return a;
  }
  /*!
   * MorphSVGPlugin 3.0.0
   * https://greensock.com
   *
   * @license Copyright 2008-2019, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
   */ function z() {
    return r || ("undefined" != typeof window && (r = window.gsap) && r.registerPlugin && r);
  }
  function M(t) {
    return console && console.warn(t);
  }
  function O(t) {
    var e,
      r = t.length,
      n = 0,
      o = 0;
    for (e = 0; e < r; e++) (n += t[e++]), (o += t[e]);
    return [n / (r / 2), o / (r / 2)];
  }
  function P(t) {
    var e,
      r,
      n,
      o = t.length,
      a = t[0],
      i = a,
      s = t[1],
      h = s;
    for (n = 6; n < o; n += 6)
      a < (e = t[n]) ? (a = e) : e < i && (i = e), s < (r = t[n + 1]) ? (s = r) : r < h && (h = r);
    return (t.centerX = (a + i) / 2), (t.centerY = (s + h) / 2), (t.size = (a - i) * (s - h));
  }
  function Q(t, e) {
    void 0 === e && (e = 3);
    for (
      var r,
        n,
        o,
        a,
        i,
        s,
        h,
        l,
        g,
        c,
        p,
        f,
        u,
        d,
        P,
        _,
        v = t.length,
        m = t[0][0],
        y = m,
        w = t[0][1],
        M = w,
        x = 1 / e;
      -1 < --v;

    )
      for (r = (i = t[v]).length, a = 6; a < r; a += 6)
        for (
          g = i[a],
            c = i[a + 1],
            p = i[a + 2] - g,
            d = i[a + 3] - c,
            f = i[a + 4] - g,
            P = i[a + 5] - c,
            u = i[a + 6] - g,
            _ = i[a + 7] - c,
            s = e;
          -1 < --s;

        )
          m < (n = ((h = x * s) * h * u + 3 * (l = 1 - h) * (h * f + l * p)) * h + g)
            ? (m = n)
            : n < y && (y = n),
            w < (o = (h * h * _ + 3 * l * (h * P + l * d)) * h + c) ? (w = o) : o < M && (M = o);
    return (
      (t.centerX = (m + y) / 2),
      (t.centerY = (w + M) / 2),
      (t.left = y),
      (t.width = m - y),
      (t.top = M),
      (t.height = w - M),
      (t.size = (m - y) * (w - M))
    );
  }
  function R(t, e) {
    return e.length - t.length;
  }
  function S(t, e) {
    var r = t.size || P(t),
      n = e.size || P(e);
    return Math.abs(n - r) < (r + n) / 20 ? e.centerX - t.centerX || e.centerY - t.centerY : n - r;
  }
  function T(t, e) {
    var r,
      n,
      o = t.slice(0),
      a = t.length,
      i = a - 2;
    for (e |= 0, r = 0; r < a; r++) (n = (r + e) % i), (t[r++] = o[n]), (t[r] = o[1 + n]);
  }
  function U(t, e, r, n, o) {
    var a,
      i,
      s,
      h,
      l = t.length,
      g = 0,
      c = l - 2;
    for (r *= 6, i = 0; i < l; i += 6)
      (h = t[(a = (i + r) % c)] - (e[i] - n)),
        (s = t[1 + a] - (e[i + 1] - o)),
        (g += _(s * s + h * h));
    return g;
  }
  function V(t, e, r) {
    var n,
      o,
      a,
      i = t.length,
      s = O(t),
      h = O(e),
      l = h[0] - s[0],
      g = h[1] - s[1],
      c = U(t, e, 0, l, g),
      p = 0;
    for (a = 6; a < i; a += 6) (o = U(t, e, a / 6, l, g)) < c && ((c = o), (p = a));
    if (r)
      for (reverseSegment((n = t.slice(0))), a = 6; a < i; a += 6)
        (o = U(n, e, a / 6, l, g)) < c && ((c = o), (p = -a));
    return p / 6;
  }
  function W(t, e, r) {
    for (var n, o, a, i, s, h, l = t.length, g = 1e20, c = 0, p = 0; -1 < --l; )
      for (h = (n = t[l]).length, s = 0; s < h; s += 6)
        (o = n[s] - e),
          (a = n[s + 1] - r),
          (i = _(o * o + a * a)) < g && ((g = i), (c = n[s]), (p = n[s + 1]));
    return [c, p];
  }
  function X(t, e, r, n, o, a) {
    var i,
      s,
      h,
      l,
      g = e.length,
      c = 0,
      p = Math.min(t.size || P(t), e[r].size || P(e[r])) * n,
      f = 1e20,
      u = t.centerX + o,
      d = t.centerY + a;
    for (i = r; i < g && !((e[i].size || P(e[i])) < p); i++)
      (s = e[i].centerX - u),
        (h = e[i].centerY - d),
        (l = _(s * s + h * h)) < f && ((c = i), (f = l));
    return (l = e[c]), e.splice(c, 1), l;
  }
  function Y(t, e) {
    var r,
      n,
      o,
      a,
      i,
      s,
      h,
      l,
      g,
      c,
      p,
      f,
      u,
      d,
      P = 0,
      _ = t.length,
      v = e / ((_ - 2) / 6);
    for (u = 2; u < _; u += 6)
      for (P += v; 0.999999 < P; )
        (r = t[u - 2]),
          (n = t[u - 1]),
          (o = t[u]),
          (a = t[u + 1]),
          (i = t[u + 2]),
          (s = t[u + 3]),
          (h = t[u + 4]),
          (l = t[u + 5]),
          (g = r + (o - r) * (d = 1 / ((Math.floor(P) || 1) + 1))),
          (g += ((p = o + (i - o) * d) - g) * d),
          (p += (i + (h - i) * d - p) * d),
          (c = n + (a - n) * d),
          (c += ((f = a + (s - a) * d) - c) * d),
          (f += (s + (l - s) * d - f) * d),
          t.splice(
            u,
            4,
            r + (o - r) * d,
            n + (a - n) * d,
            g,
            c,
            g + (p - g) * d,
            c + (f - c) * d,
            p,
            f,
            i + (h - i) * d,
            s + (l - s) * d
          ),
          (u += 6),
          (_ += 6),
          P--;
    return t;
  }
  function Z(t, e, r, n, o) {
    var a,
      i,
      s,
      h,
      l,
      g,
      c,
      p = e.length - t.length,
      f = 0 < p ? e : t,
      u = 0 < p ? t : e,
      d = 0,
      _ = "complexity" === n ? R : S,
      v = "position" === n ? 0 : "number" == typeof n ? n : 0.8,
      m = u.length,
      y = "object" == typeof r && r.push ? r.slice(0) : [r],
      w = "reverse" === y[0] || y[0] < 0,
      x = "log" === r;
    if (u[0]) {
      if (
        1 < f.length &&
        (t.sort(_),
        e.sort(_),
        f.size || Q(f),
        u.size || Q(u),
        (g = f.centerX - u.centerX),
        (c = f.centerY - u.centerY),
        _ === S)
      )
        for (m = 0; m < u.length; m++) f.splice(m, 0, X(u[m], f, m, v, g, c));
      if (p)
        for (
          p < 0 && (p = -p),
            f[0].length > u[0].length && Y(u[0], ((f[0].length - u[0].length) / 6) | 0),
            m = u.length;
          d < p;

        )
          f[m].size || P(f[m]),
            (h = (s = W(u, f[m].centerX, f[m].centerY))[0]),
            (l = s[1]),
            (u[m++] = [h, l, h, l, h, l, h, l]),
            (u.totalPoints += 8),
            d++;
      for (m = 0; m < t.length; m++)
        (a = e[m]),
          (i = t[m]),
          (p = a.length - i.length) < 0 ? Y(a, (-p / 6) | 0) : 0 < p && Y(i, (p / 6) | 0),
          w && !1 !== o && !i.reversed && reverseSegment(i),
          (r = y[m] || 0 === y[m] ? y[m] : "auto") &&
            (i.closed ||
            (Math.abs(i[0] - i[i.length - 2]) < 0.5 && Math.abs(i[1] - i[i.length - 1]) < 0.5)
              ? "auto" === r || "log" === r
                ? ((y[m] = r = V(i, a, !m || !1 === o)),
                  r < 0 && ((w = !0), reverseSegment(i), (r = -r)),
                  T(i, 6 * r))
                : "reverse" !== r && (m && r < 0 && reverseSegment(i), T(i, 6 * (r < 0 ? -r : r)))
              : !w &&
                (("auto" === r &&
                  Math.abs(a[0] - i[0]) +
                    Math.abs(a[1] - i[1]) +
                    Math.abs(a[a.length - 2] - i[i.length - 2]) +
                    Math.abs(a[a.length - 1] - i[i.length - 1]) >
                    Math.abs(a[0] - i[i.length - 2]) +
                      Math.abs(a[1] - i[i.length - 1]) +
                      Math.abs(a[a.length - 2] - i[0]) +
                      Math.abs(a[a.length - 1] - i[1])) ||
                  r % 2)
              ? (reverseSegment(i), (y[m] = -1), (w = !0))
              : "auto" === r
              ? (y[m] = 0)
              : "reverse" === r && (y[m] = -1),
            i.closed !== a.closed && (i.closed = a.closed = !1));
      return x && M("shapeIndex:[" + y.join(",") + "]"), (t.shapeIndex = y);
    }
  }
  function aa(t, e) {
    var r,
      n,
      o,
      a,
      i,
      s,
      h,
      l = 0,
      g = parseFloat(t[0]),
      c = parseFloat(t[1]),
      p = g + "," + c + " ";
    for (r = (0.5 * e) / (0.5 * (o = t.length) - 1), n = 0; n < o - 2; n += 2) {
      if (((l += r), (s = parseFloat(t[n + 2])), (h = parseFloat(t[n + 3])), 0.999999 < l))
        for (i = 1 / (Math.floor(l) + 1), a = 1; 0.999999 < l; )
          (p += (g + (s - g) * i * a).toFixed(2) + "," + (c + (h - c) * i * a).toFixed(2) + " "),
            l--,
            a++;
      (p += s + "," + h + " "), (g = s), (c = h);
    }
    return p;
  }
  function ba(t) {
    var e = t[0].match(L) || [],
      r = t[1].match(L) || [],
      n = r.length - e.length;
    0 < n ? (t[0] = aa(e, n)) : (t[1] = aa(r, -n));
  }
  function ca(e) {
    return isNaN(e)
      ? ba
      : function (t) {
          ba(t),
            (t[1] = (function _offsetPoints(t, e) {
              if (!e) return t;
              var r,
                n,
                o,
                a = t.match(L) || [],
                i = a.length,
                s = "";
              for (
                r =
                  "reverse" === e
                    ? ((n = i - 1), -2)
                    : ((n = (2 * (parseInt(e, 10) || 0) + 1 + 100 * i) % i), 2),
                  o = 0;
                o < i;
                o += 2
              )
                (s += a[n - 1] + "," + a[n] + " "), (n = (n + r) % i);
              return s;
            })(t[1], parseInt(e, 10)));
        };
  }
  function ea(t, e) {
    for (var r, n, o, a, i, s, h, l, g, c, p, f, u = t.length, d = 0.2 * (e || 1); -1 < --u; ) {
      for (
        p = (n = t[u]).isSmooth = n.isSmooth || [0, 0, 0, 0],
          f = n.smoothData = n.smoothData || [0, 0, 0, 0],
          p.length = 4,
          l = n.length - 2,
          h = 6;
        h < l;
        h += 6
      )
        (o = n[h] - n[h - 2]),
          (a = n[h + 1] - n[h - 1]),
          (i = n[h + 2] - n[h]),
          (s = n[h + 3] - n[h + 1]),
          (g = y(a, o)),
          (c = y(s, i)),
          (r = Math.abs(g - c) < d) &&
            ((f[h - 2] = g),
            (f[h + 2] = c),
            (f[h - 1] = _(o * o + a * a)),
            (f[h + 3] = _(i * i + s * s))),
          p.push(r, r, 0, 0, r, r);
      n[l] === n[0] &&
        n[1 + l] === n[1] &&
        ((o = n[0] - n[l - 2]),
        (a = n[1] - n[l - 1]),
        (i = n[2] - n[0]),
        (s = n[3] - n[1]),
        (g = y(a, o)),
        (c = y(s, i)),
        Math.abs(g - c) < d &&
          ((f[l - 2] = g),
          (f[2] = c),
          (f[l - 1] = _(o * o + a * a)),
          (f[3] = _(i * i + s * s)),
          (p[l - 2] = p[l - 1] = !0)));
    }
    return t;
  }
  function fa(t) {
    var e = t.trim().split(" ");
    return {
      x:
        (~t.indexOf("left")
          ? 0
          : ~t.indexOf("right")
          ? 100
          : isNaN(parseFloat(e[0]))
          ? 50
          : parseFloat(e[0])) / 100,
      y:
        (~t.indexOf("top")
          ? 0
          : ~t.indexOf("bottom")
          ? 100
          : isNaN(parseFloat(e[1]))
          ? 50
          : parseFloat(e[1])) / 100,
    };
  }
  function ia(t, e, r, n) {
    var o,
      a,
      i = this._origin,
      s = this._eOrigin,
      h = t[r] - i.x,
      l = t[r + 1] - i.y,
      g = _(h * h + l * l),
      c = y(l, h);
    return (
      (h = e[r] - s.x),
      (l = e[r + 1] - s.y),
      (a = (function _shortAngle(t) {
        return t !== t % p ? t + (t < 0 ? f : -f) : t;
      })((o = y(l, h) - c))),
      !n && C && Math.abs(a + C.ca) < u && (n = C),
      (this._anchorPT = C =
        {
          _next: this._anchorPT,
          t: t,
          sa: c,
          ca: n && a * n.ca < 0 && Math.abs(a) > d ? o : a,
          sl: g,
          cl: _(h * h + l * l) - g,
          i: r,
        })
    );
  }
  function ja(t) {
    (r = z()),
      (a = a || (r && r.plugins.morphSVG)),
      r && a
        ? ((j = r.utils.toArray), (a.prototype._tweenRotation = ia), (F = 1))
        : t && M("Please gsap.registerPlugin(MorphSVGPlugin)");
  }
  var r,
    j,
    C,
    F,
    a,
    y = Math.atan2,
    b = Math.cos,
    I = Math.sin,
    _ = Math.sqrt,
    p = Math.PI,
    f = 2 * p,
    u = 0.3 * p,
    d = 0.7 * p,
    L = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
    G = /(^[#\.][a-z]|[a-y][a-z])/gi,
    H = /[achlmqstvz]/gi,
    q = "Use MorphSVGPlugin.convertToPath() to convert to a path before morphing.",
    J = {
      version: "3.0.0",
      name: "morphSVG",
      register: function register(t, e) {
        (r = t), (a = e), ja();
      },
      init: function init(t, e, r, n, o) {
        var a,
          i,
          s,
          h,
          l,
          g,
          c,
          p,
          f,
          u,
          d,
          P,
          _,
          v,
          m,
          y,
          w,
          x,
          T,
          b,
          S,
          N,
          z = t.nodeType ? window.getComputedStyle(t) : {},
          R = z.fill + "",
          A = !("none" === R || "0" === (R.match(L) || [])[3] || "evenodd" === z.fillRule),
          O = (e.origin || "50 50").split(",");
        if (
          (F || ja(1),
          (l = "POLYLINE" === (a = (t.nodeName + "").toUpperCase()) || "POLYGON" === a),
          "PATH" !== a && !l && !e.prop)
        )
          return M("Cannot morph a <" + a + "> element. " + q), !1;
        if (
          ((i = "PATH" === a ? "d" : "points"),
          ("string" == typeof e || e.getBBox || e[0]) && (e = { shape: e }),
          !e.prop && "function" != typeof t.setAttribute)
        )
          return !1;
        if (
          ((h = (function _parseShape(t, e, r) {
            var n, o;
            return (
              (!("string" == typeof t) || G.test(t) || (t.match(L) || []).length < 3) &&
                ((n = j(t)[0])
                  ? ((o = (n.nodeName + "").toUpperCase()),
                    e && "PATH" !== o && ((n = convertToPath(n, !1)), (o = "PATH")),
                    (t = n.getAttribute("PATH" === o ? "d" : "points") || ""),
                    n === r && (t = n.getAttributeNS(null, "data-original") || t))
                  : (M("WARNING: invalid morph to: " + t), (t = !1))),
              t
            );
          })(e.shape || e.d || e.points || "", "d" == i, t)),
          l && H.test(h))
        )
          return M("A <" + a + "> cannot accept path data. " + q), !1;
        if (
          ((g = e.shapeIndex || 0 === e.shapeIndex ? e.shapeIndex : "auto"),
          (c = e.map || J.defaultMap),
          (this._prop = e.prop),
          (this._render = e.render || J.defaultRender),
          (this._apply = "updateTarget" in e ? e.updateTarget : J.defaultUpdateTarget),
          (this._rnd = Math.pow(10, isNaN(e.precision) ? 2 : +e.precision)),
          (this._tween = r),
          h)
        ) {
          if (
            ((this._target = t),
            (w = "object" == typeof e.precompile),
            (u = this._prop ? t[this._prop] : t.getAttribute(i)),
            this._prop ||
              t.getAttributeNS(null, "data-original") ||
              t.setAttributeNS(null, "data-original", u),
            "d" == i || this._prop)
          ) {
            if (
              ((u = stringToRawPath(w ? e.precompile[0] : u)),
              (d = stringToRawPath(w ? e.precompile[1] : h)),
              !w && !Z(u, d, g, c, A))
            )
              return !1;
            for (
              ("log" !== e.precompile && !0 !== e.precompile) ||
                M('precompile:["' + rawPathToString(u) + '","' + rawPathToString(d) + '"]'),
                (S = "linear" !== (e.type || J.defaultType)) &&
                  ((u = ea(u, e.smoothTolerance)),
                  (d = ea(d, e.smoothTolerance)),
                  u.size || Q(u),
                  d.size || Q(d),
                  (b = fa(O[0])),
                  (this._origin = u.origin =
                    { x: u.left + b.x * u.width, y: u.top + b.y * u.height }),
                  O[1] && (b = fa(O[1])),
                  (this._eOrigin = { x: d.left + b.x * d.width, y: d.top + b.y * d.height })),
                this._rawPath = t._gsRawPath = u,
                _ = u.length;
              -1 < --_;

            )
              for (
                m = u[_],
                  y = d[_],
                  p = m.isSmooth || [],
                  f = y.isSmooth || [],
                  v = m.length,
                  P = C = 0;
                P < v;
                P += 2
              )
                (y[P] === m[P] && y[P + 1] === m[P + 1]) ||
                  (S
                    ? p[P] && f[P]
                      ? ((x = m.smoothData),
                        (T = y.smoothData),
                        (N = P + (P === v - 4 ? 7 - v : 5)),
                        (this._controlPT = {
                          _next: this._controlPT,
                          i: P,
                          j: _,
                          l1s: x[P + 1],
                          l1c: T[P + 1] - x[P + 1],
                          l2s: x[N],
                          l2c: T[N] - x[N],
                        }),
                        (s = this._tweenRotation(m, y, P + 2)),
                        this._tweenRotation(m, y, P, s),
                        this._tweenRotation(m, y, N - 1, s),
                        (P += 4))
                      : this._tweenRotation(m, y, P)
                    : ((s = this.add(m, P, m[P], y[P])),
                      (s = this.add(m, P + 1, m[P + 1], y[P + 1]) || s)));
          } else s = this.add(t, "setAttribute", t.getAttribute(i) + "", h + "", n, o, 0, ca(g), i);
          S &&
            (this.add(this._origin, "x", this._origin.x, this._eOrigin.x),
            (s = this.add(this._origin, "y", this._origin.y, this._eOrigin.y))),
            s && (this._props.push("morphSVG"), (s.end = h), (s.endProp = i));
        }
        return 1;
      },
      render: function render(t, e) {
        for (
          var r,
            n,
            o,
            a,
            i,
            s,
            h,
            l,
            g,
            c,
            p,
            f,
            u = e._rawPath,
            d = e._controlPT,
            P = e._anchorPT,
            _ = e._rnd,
            v = e._target,
            m = e._pt;
          m;

        )
          m.r(t, m.d), (m = m._next);
        if (1 === t && e._apply)
          for (m = e._pt; m; )
            m.end && (e._prop ? (v[e._prop] = m.end) : v.setAttribute(m.endProp, m.end)),
              (m = m._next);
        else if (u) {
          for (; P; )
            (i = P.sa + t * P.ca),
              (a = P.sl + t * P.cl),
              (P.t[P.i] = e._origin.x + b(i) * a),
              (P.t[P.i + 1] = e._origin.y + I(i) * a),
              (P = P._next);
          for (n = t < 0.5 ? 2 * t * t : (4 - 2 * t) * t - 1; d; )
            (f = (s = d.i) + (s === (o = u[d.j]).length - 4 ? 7 - o.length : 5)),
              (i = y(o[f] - o[s + 1], o[f - 1] - o[s])),
              (c = I(i)),
              (p = b(i)),
              (l = o[s + 2]),
              (g = o[s + 3]),
              (a = d.l1s + n * d.l1c),
              (o[s] = l - p * a),
              (o[s + 1] = g - c * a),
              (a = d.l2s + n * d.l2c),
              (o[f - 1] = l + p * a),
              (o[f] = g + c * a),
              (d = d._next);
          if (((v._gsRawPath = u), e._apply)) {
            for (r = "", " ", h = 0; h < u.length; h++)
              for (
                a = (o = u[h]).length,
                  r += "M" + ((o[0] * _) | 0) / _ + " " + ((o[1] * _) | 0) / _ + " C",
                  s = 2;
                s < a;
                s++
              )
                r += ((o[s] * _) | 0) / _ + " ";
            e._prop ? (v[e._prop] = r) : v.setAttribute("d", r);
          }
        }
        e._render && u && e._render.call(e._tween, u, v);
      },
      getRawPath: function getRawPath(t) {
        var e,
          r = (t = (n(t) && o.test(t) && document.querySelector(t)) || t).getAttribute ? t : 0;
        return r && (t = t.getAttribute("d"))
          ? (r._gsPath || (r._gsPath = {}),
            (e = r._gsPath[t]) && !e._dirty ? e : (r._gsPath[t] = stringToRawPath(t)))
          : t
          ? n(t)
            ? stringToRawPath(t)
            : s(t[0])
            ? [t]
            : t
          : console.warn("Expecting a <path> element or an SVG path data string");
      },
      stringToRawPath: stringToRawPath,
      rawPathToString: rawPathToString,
      pathFilter: function _pathFilter(t, e, r, n, o) {
        var a = stringToRawPath(t[0]),
          i = stringToRawPath(t[1]);
        Z(a, i, e || 0 === e ? e : "auto", r, o) &&
          ((t[0] = rawPathToString(a)),
          (t[1] = rawPathToString(i)),
          ("log" !== n && !0 !== n) || M('precompile:["' + t[0] + '","' + t[1] + '"]'));
      },
      pointsFilter: ba,
      getTotalSize: Q,
      convertToPath: function convertToPath$1(t, e) {
        return j(t).map(function (t) {
          return convertToPath(t, !1 !== e);
        });
      },
      defaultType: "linear",
      defaultUpdateTarget: !0,
      defaultMap: "size",
    };
  z() && r.registerPlugin(J),
    (t.MorphSVGPlugin = J),
    (t.default = J),
    Object.defineProperty(t, "__esModule", { value: !0 });
});
